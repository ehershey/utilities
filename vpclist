#!/bin/bash
#
# vpclist
#
# List VPC's with caching. All arguments are case-insensitive grep patterns to filter by.
#
# Example:
# vpclist vpc30
#
#
set -o nounset
set -o pipefail
set -o errexit

if [ \( ! "${AWS_SECRET_ACCESS_KEY:-}" -o ! "${AWS_ACCESS_KEY_ID:-}" \) -a ! "${AWS_PROFILE:-}" ]
then
  echo "Must set either: \$AWS_PROFILE or \$AWS_SECRET_ACCESS_KEY and \$AWS_ACCESS_KEY_ID"
  exit 2
fi

# default seconds to cache describe-instances output
#
DEFAULT_TIMEOUT=300

# allow overriding output cache timeout by specifying $VPCLIST_CACHE_TIMEOUT
#
if [ "${VPCLIST_CACHE_TIMEOUT:-}" ]
then
  timeout=$VPCLIST_CACHE_TIMEOUT
else
  timeout=$DEFAULT_TIMEOUT
fi

log() {
  LOG="/tmp/vpclist.log"
  #date >> $LOG
  #echo "$*" >> $LOG
}

log "timeout: $timeout"

# use the userid hitting aws as a cache subkey so instance lists from different accounts will be cached separately
#
CACHE_SUB_KEY="$(cache_run 99999999 "aws sts get-caller-identity --query 'UserId' --output text" "${AWS_ACCESS_KEY_ID:-}-.-${AWS_PROFILE:-}" )"

tempfile=$(mktemp /tmp/vpclist.XXXXXX)
tempfile2=$(mktemp /tmp/vpclist.XXXXXX)

regions=$(cache_run 9999999 "aws ec2 describe-regions  --query Regions[*].RegionName --output text" $CACHE_SUB_KEY | sed 's/ap-northeast-2//')
printed_header=""
for region in $regions
do
  if [ ! "$printed_header" ]
    then
      cache_run $timeout "aws --region $region ec2 describe-vpcs | format_vpc_json.js" $CACHE_SUB_KEY >> $tempfile &
      printed_header=1
    else
      cache_run $timeout "aws --region $region ec2 describe-vpcs | format_vpc_json.js" $CACHE_SUB_KEY | tail -n +2 >> $tempfile &
    fi
done
wait
while [ "${1:-}" ]
do
  cat "$tempfile" | grep -i "$1" > "$tempfile2"
  cat "$tempfile2" > "$tempfile"
  shift
done

cat $tempfile

